<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <title>ãƒªã‚¢ãƒ«ã‚¿ã‚¤ãƒ é¡”è¿½è·¡ã‚¢ãƒã‚¿ãƒ¼ã€æœ€çµ‚å®Œæˆç‰ˆã€‘</title>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/face_mesh/face_mesh.js" crossorigin="anonymous"></script>
    
    <style>
        body { font-family: 'Helvetica Neue', Arial, sans-serif; background-color: #f0f2f5; color: #333; margin: 0; padding: 20px; }
        .app-container { max-width: 1600px; margin: auto; display: grid; grid-template-columns: 2fr 1fr; gap: 20px; align-items: flex-start; }
        .column { background-color: white; padding: 20px; border-radius: 8px; box-shadow: 0 4px 8px rgba(0,0,0,0.1); }
        h1, h2, h3, h4 { color: #1a73e8; margin-top: 0; }
        h4 { margin-bottom: 5px; text-align: center;}
        #status { color: #555; margin-bottom: 20px; min-height: 20px; font-weight: bold; }
        .viewer-container { border-radius: 8px; overflow: hidden; border: 1px solid #ddd; }
        video, canvas { width: 100%; height: auto; display: block; background-color: #000; }
        .controls { display: flex; flex-direction: column; gap: 15px; }
        .button-group { display: flex; gap: 10px; }
        button, label.button { flex: 1; padding: 12px; font-size: 16px; color: white; border: none; border-radius: 5px; cursor: pointer; text-align: center; }
        #webcamButton { background-color: #1a73e8; }
        label.button { background-color: #34a853; }
        #downloadButton { background-color: #ff6f61; }
        input[type="file"] { display: none; }
        #angles-display { background-color: #e8f0fe; padding: 15px; border-radius: 5px; font-family: monospace; border-left: 5px solid #1a73e8; }
        .video-grid { display: grid; grid-template-columns: 1fr 1fr; gap: 15px; margin-top: 20px; }
        .video-box { border: 1px solid #ddd; border-radius: 8px; overflow: hidden; }
    </style>
</head>
<body>

    <div style="text-align: center; margin-bottom: 20px;">
        <h1>ãƒªã‚¢ãƒ«ã‚¿ã‚¤ãƒ é¡”è¿½è·¡ï¼†ã‚¢ãƒã‚¿ãƒ¼åŒæ™‚å†ç¾ã€å®Œæˆç‰ˆã€‘ ğŸš€</h1>
        <p id="status">AIãƒ¢ãƒ‡ãƒ«ã‚’èª­ã¿è¾¼ã‚“ã§ã„ã¾ã™...</p>
    </div>

    <div class="app-container">
        <div class="column">
            <h2>ã‚³ãƒ³ãƒˆãƒ­ãƒ¼ãƒ«ï¼†ã‚«ãƒ¡ãƒ©æ˜ åƒ</h2>
            <div class="controls">
                <div class="button-group">
                    <button id="webcamButton">Webã‚«ãƒ¡ãƒ©é–‹å§‹</button>
                    <label for="videoFileInput" class="button">å‹•ç”»ãƒ•ã‚¡ã‚¤ãƒ«é¸æŠ</label>
                    <input type="file" id="videoFileInput" accept="video/*">
                </div>
                <button id="downloadButton">ä»Šå›ã®è¨˜éŒ²ã‚’CSVã§ãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰</button>
            </div>
            <h3 style="margin-top: 20px;">ãƒªã‚¢ãƒ«ã‚¿ã‚¤ãƒ è§’åº¦ (åº¦)</h3>
            <div id="angles-display">
                Yaw (å·¦å³): 0.00 <br> Pitch (ä¸Šä¸‹): 0.00 <br> Roll (å‚¾ã): 0.00
            </div>
            <div class="video-grid">
                <div><h4>å…ƒæ˜ åƒ (Original)</h4><div class="video-box"><video id="input_video" autoplay muted playsinline></video></div></div>
                <div><h4>ãƒ¡ãƒƒã‚·ãƒ¥ä»˜ãæ˜ åƒ (Processed)</h4><div class="video-box"><canvas id="output_canvas"></canvas></div></div>
            </div>
        </div>
        <div class="column">
            <h2>ã‚¢ãƒã‚¿ãƒ¼ãƒ“ãƒ¥ãƒ¼ã‚¢</h2>
            <div class="viewer-container"><canvas id="avatarCanvas"></canvas></div>
        </div>
    </div>

<script type="importmap">
    { "imports": { "three": "https://unpkg.com/three@0.160.0/build/three.module.js", "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/" } }
</script>

<script type="module">
    import * as THREE from 'three';
    import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

    // --- 1. å®šæ•°ã¨ã‚°ãƒ­ãƒ¼ãƒãƒ«å¤‰æ•°ã®å®šç¾© ---

    // ãƒ©ãƒ³ãƒ‰ãƒãƒ¼ã‚¯IDã«åå‰ã‚’ä»˜ã‘ã¦åˆ†ã‹ã‚Šã‚„ã™ãã™ã‚‹
    const LANDMARKS = {
        FOREHEAD: 10,      // é¡
        CHIN: 152,         // é¡
        RIGHT_TEMPLE: 234, // å³ã“ã‚ã‹ã¿
        LEFT_TEMPLE: 454,  // å·¦ã“ã‚ã‹ã¿
    };

    // DOMè¦ç´ 
    const dom = {
        statusText: document.getElementById('status'),
        videoElement: document.getElementById('input_video'),
        outputCanvas: document.getElementById('output_canvas'),
        avatarCanvas: document.getElementById('avatarCanvas'),
        webcamButton: document.getElementById('webcamButton'),
        videoFileInput: document.getElementById('videoFileInput'),
        downloadButton: document.getElementById('downloadButton'),
        anglesDisplay: document.getElementById('angles-display'),
    };

    // çŠ¶æ…‹ç®¡ç†
    let logData = [];
    let avatarNode = null;

    // Three.jsã®å†åˆ©ç”¨ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆ (ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹æœ€é©åŒ–)
    const three = {
        scene: new THREE.Scene(),
        camera: new THREE.PerspectiveCamera(50, 640 / 480, 0.1, 1000),
        renderer: new THREE.WebGLRenderer({ canvas: dom.avatarCanvas, antialias: true }),
        controls: null, // åˆæœŸåŒ–æ™‚ã«è¨­å®š
        matrix: new THREE.Matrix4(),
        baseRotation: new THREE.Quaternion().setFromEuler(new THREE.Euler(0, 0, Math.PI)),
        faceRotation: new THREE.Quaternion(),
    };

    // MediaPipeã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹
    const faceMesh = new FaceMesh({ locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/face_mesh/${file}` });
    const mediaPipeCamera = new Camera(dom.videoElement, {
        onFrame: async () => await faceMesh.send({ image: dom.videoElement }),
        width: 640, height: 480
    });

    // --- 2. åˆæœŸè¨­å®šé–¢æ•° ---

    /** Three.jsã®ã‚·ãƒ¼ãƒ³ã‚’ã‚»ãƒƒãƒˆã‚¢ãƒƒãƒ—ã™ã‚‹ */
    function setupThreeScene() {
        three.scene.background = new THREE.Color(0xdddddd);
        three.camera.position.set(0, 1.2, 2.5);
        three.renderer.setSize(640, 480);
        three.controls = new OrbitControls(three.camera, three.renderer.domElement);
        three.controls.target.set(0, 1.0, 0);
        
        three.scene.add(new THREE.AmbientLight(0xffffff, 1.5));
        const directionalLight = new THREE.DirectionalLight(0xffffff, 1.5);
        directionalLight.position.set(1, 2, 3);
        three.scene.add(directionalLight);

        const modelData = { "metadata": { "version": 4.5, "type": "Object" }, "geometries": [{ "uuid": "head_geom", "type": "SphereGeometry", "radius": 0.4, "widthSegments": 32, "heightSegments": 16 },{ "uuid": "neck_geom", "type": "CylinderGeometry", "radiusTop": 0.15, "radiusBottom": 0.15, "height": 0.4 },{ "uuid": "nose_geom", "type": "BoxGeometry", "width": 0.1, "height": 0.1, "depth": 0.15 }], "materials": [{ "uuid": "face_mat", "type": "MeshStandardMaterial", "color": "0xeeeeee", "roughness": 0.5 },{ "uuid": "neck_mat", "type": "MeshStandardMaterial", "color": "0xcccccc", "roughness": 0.5 },{ "uuid": "nose_mat", "type": "MeshStandardMaterial", "color": "0xffa500" }], "object": { "uuid": "avatarNode", "type": "Group", "position": [0, 0.8, 0], "children": [{ "uuid": "head", "type": "Mesh", "geometry": "head_geom", "material": "face_mat", "position": [0, 0.4, 0] },{ "uuid": "neck", "type": "Mesh", "geometry": "neck_geom", "material": "neck_mat", "position": [0, -0.05, 0] },{ "uuid": "nose", "type": "Mesh", "geometry": "nose_geom", "material": "nose_mat", "position": [0, 0.4, 0.4] }]}};
        avatarNode = new THREE.ObjectLoader().parse(modelData);
        avatarNode.rotation.z = Math.PI; // åˆæœŸå‘ãã‚’180åº¦å›è»¢
        three.scene.add(avatarNode);
    }

    /** MediaPipeã‚’ã‚»ãƒƒãƒˆã‚¢ãƒƒãƒ—ã™ã‚‹ */
    function setupMediaPipe() {
        faceMesh.setOptions({ maxNumFaces: 1, refineLandmarks: true, minDetectionConfidence: 0.5, minTrackingConfidence: 0.5 });
        faceMesh.onResults(onMediaPipeResults);
    }

    // --- 3. ã‚¤ãƒ™ãƒ³ãƒˆãƒªã‚¹ãƒŠãƒ¼ã®è¨­å®š ---

    function setupEventListeners() {
        dom.webcamButton.addEventListener('click', startWebcam);
        dom.videoFileInput.addEventListener('change', startVideoFile);
        dom.downloadButton.addEventListener('click', downloadCSV);
    }

    // --- 4. ãƒ¡ã‚¤ãƒ³ãƒ­ã‚¸ãƒƒã‚¯ ---

    /** MediaPipeã‹ã‚‰çµæœãŒè¿”ã•ã‚ŒãŸã¨ãã®å‡¦ç† */
    function onMediaPipeResults(results) {
        const canvasCtx = dom.outputCanvas.getContext('2d');
        canvasCtx.save();
        canvasCtx.clearRect(0, 0, dom.outputCanvas.width, dom.outputCanvas.height);
        canvasCtx.drawImage(results.image, 0, 0, dom.videoElement.videoWidth, dom.videoElement.videoHeight);

        if (results.multiFaceLandmarks && results.multiFaceLandmarks[0]) {
            drawConnectors(canvasCtx, results.multiFaceLandmarks[0], FACEMESH_TESSELATION, { color: '#C0C0C070', lineWidth: 1 });
            const angles = calculateFaceAngles(results.multiFaceLandmarks[0]);
            if (angles) {
                updateDisplays(angles);
                updateAvatarPose(angles);
            }
        }
        canvasCtx.restore();
    }
    
    /** ãƒ©ãƒ³ãƒ‰ãƒãƒ¼ã‚¯ã‹ã‚‰é¡”ã®è§’åº¦ã‚’è¨ˆç®—ã™ã‚‹ */
    function calculateFaceAngles(landmarks) {
        const p1 = new THREE.Vector3(landmarks[LANDMARKS.FOREHEAD].x, landmarks[LANDMARKS.FOREHEAD].y, landmarks[LANDMARKS.FOREHEAD].z);
        const p2 = new THREE.Vector3(landmarks[LANDMARKS.CHIN].x, landmarks[LANDMARKS.CHIN].y, landmarks[LANDMARKS.CHIN].z);
        const p3 = new THREE.Vector3(landmarks[LANDMARKS.RIGHT_TEMPLE].x, landmarks[LANDMARKS.RIGHT_TEMPLE].y, landmarks[LANDMARKS.RIGHT_TEMPLE].z);
        const p4 = new THREE.Vector3(landmarks[LANDMARKS.LEFT_TEMPLE].x, landmarks[LANDMARKS.LEFT_TEMPLE].y, landmarks[LANDMARKS.LEFT_TEMPLE].z);

        const upVec = new THREE.Vector3().subVectors(p1, p2);
        const rightVec = new THREE.Vector3().subVectors(p3, p4);
        const forwardVec = new THREE.Vector3().crossVectors(rightVec, upVec).normalize();
        const rightVecNorm = rightVec.clone().normalize();
        const upVecNorm = new THREE.Vector3().crossVectors(forwardVec, rightVecNorm).normalize();
        
        three.matrix.makeBasis(rightVecNorm, upVecNorm, forwardVec);
        const euler = new THREE.Euler().setFromRotationMatrix(three.matrix, 'YXZ');

        return {
            yaw: euler.y * (180 / Math.PI),
            pitch: euler.x * (180 / Math.PI) * -1,
            roll: euler.z * (180 / Math.PI) * -1,
        };
    }

    /** ã‚¢ãƒã‚¿ãƒ¼ã®å§¿å‹¢ã‚’æ›´æ–°ã™ã‚‹ (æœ€é©åŒ–ç‰ˆ) */
    function updateAvatarPose(angles) {
        if (!avatarNode) return;
        
        three.faceRotation.setFromEuler(new THREE.Euler(
            THREE.MathUtils.degToRad(angles.pitch),
            THREE.MathUtils.degToRad(angles.yaw),
            THREE.MathUtils.degToRad(angles.roll),
            'YXZ'
        ));

        avatarNode.quaternion.copy(three.baseRotation).multiply(three.faceRotation);
    }

    /** ç”»é¢ã®è§’åº¦è¡¨ç¤ºã‚’æ›´æ–°ã—ã€ãƒ‡ãƒ¼ã‚¿ã‚’è¨˜éŒ²ã™ã‚‹ */
    function updateDisplays(angles) {
        dom.anglesDisplay.innerHTML = `Yaw (å·¦å³): ${angles.yaw.toFixed(2)} <br> Pitch (ä¸Šä¸‹): ${angles.pitch.toFixed(2)} <br> Roll (å‚¾ã): ${angles.roll.toFixed(2)}`;
        logData.push({ time: new Date().toLocaleTimeString(), yaw: angles.yaw.toFixed(2), pitch: angles.pitch.toFixed(2), roll: angles.roll.toFixed(2) });
    }
    
    // --- 5. ã‚³ãƒ³ãƒˆãƒ­ãƒ¼ãƒ«é–¢æ•° ---

    function startWebcam() {
        dom.statusText.textContent = 'Webã‚«ãƒ¡ãƒ©ã‚’èµ·å‹•ä¸­...';
        dom.videoElement.srcObject = null;
        dom.videoElement.removeAttribute('src');
        dom.videoElement.play();
        mediaPipeCamera.start();
    }

    function startVideoFile(event) {
        if (dom.videoElement.srcObject) {
            dom.videoElement.srcObject.getTracks().forEach(track => track.stop());
        }
        const file = event.target.files[0];
        if (!file) return;
        const url = URL.createObjectURL(file);
        dom.videoElement.src = url;
        dom.videoElement.onloadedmetadata = () => {
            dom.videoElement.play();
            dom.statusText.textContent = 'å‹•ç”»ãƒ•ã‚¡ã‚¤ãƒ«ã‚’å†ç”Ÿä¸­...';
            processVideoFrameLoop();
        }
    }

    function downloadCSV() {
        if (logData.length === 0) { alert('è¨˜éŒ²ã•ã‚ŒãŸãƒ‡ãƒ¼ã‚¿ãŒã‚ã‚Šã¾ã›ã‚“ã€‚'); return; }
        let csvContent = "data:text/csv;charset=utf-8,Time,Yaw,Pitch,Roll\r\n";
        logData.forEach(row => { csvContent += `${row.time},${row.yaw},${row.pitch},${row.roll}\r\n`; });
        const link = document.createElement("a");
        link.href = encodeURI(csvContent);
        link.download = "face_angle_log.csv";
        link.click();
    }

    // --- 6. ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ãƒ«ãƒ¼ãƒ— ---

    /** Three.jsã®ãƒ¬ãƒ³ãƒ€ãƒªãƒ³ã‚°ãƒ«ãƒ¼ãƒ— */
    function renderThreeLoop() {
        requestAnimationFrame(renderThreeLoop);
        three.controls.update();
        three.renderer.render(three.scene, three.camera);
    }

    /** å‹•ç”»ãƒ•ã‚¡ã‚¤ãƒ«ç”¨ã®å‡¦ç†ãƒ«ãƒ¼ãƒ— */
    async function processVideoFrameLoop() {
        if (dom.videoElement.paused || dom.videoElement.ended) return;
        await faceMesh.send({ image: dom.videoElement });
        requestAnimationFrame(processVideoFrameLoop);
    }

    // --- 7. åˆæœŸåŒ–ã¨å®Ÿè¡Œ ---

    (async () => {
        dom.statusText.textContent = 'åˆæœŸåŒ–ä¸­...';
        setupThreeScene();
        setupMediaPipe();
        setupEventListeners();
        renderThreeLoop();
        await faceMesh.initialize();
        dom.statusText.textContent = 'æº–å‚™å®Œäº†ã€‚Webã‚«ãƒ¡ãƒ©ã¾ãŸã¯å‹•ç”»ã‚’é¸æŠã—ã¦ãã ã•ã„ã€‚';
    })();
</script>
</body>
</html>